<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.20" xml:lang="en-US">
  <compounddef id="md_pages_tutorials_tutorial1" kind="page">
    <compoundname>md_pages_tutorials_tutorial1</compoundname>
    <title>Tutorial: Linear Decoder</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-block m-info" /></para>
<para><simplesect kind="par"><title></title><para>This tutorial shows how to create a pressio linear decoder object.</para>
</simplesect>
</para>
<sect1 id="md_pages_tutorials_tutorial1_1autotoc_md49">
<title>Context</title>
<para>A key assumption of projection-based ROMs is to approximate the full-order model (FOM) state, <formula id="3">$y_{fom}$</formula>, as: <formula id="4">\[ y_{fom} = g(y_{rom}) \]</formula></para>
<para>where <formula id="5">$y_{rom}$</formula> is the reduced state (or generalized coordinates), and <formula id="6">$g$</formula> is the mapping between the two.</para>
<para>If <formula id="6">$g$</formula> is linear, then we can write: <formula id="7">\[ y_{fom} = \phi y_{rom} \]</formula> where <formula id="8">$\phi$</formula> is a matrix (for the time being, assume it constant). The Jacobian of the mapping is: <formula id="9">\[ \frac{d y_{fom}}{d y_{rom}} = \phi. \]</formula></para>
<para>Graphically, this corresponds to: <image type="html" name="tut_f1.png" width="35%"></image>
</para>
<para><emphasis>A linear decoder in pressio implements this linear mapping.</emphasis></para>
</sect1>
<sect1 id="md_pages_tutorials_tutorial1_1autotoc_md50">
<title>Types Description</title>
<para><itemizedlist>
<listitem><para><formula id="3">$y_{fom}$</formula>: this is the FOM state and, therefore, it is a data structure of your application. For example, if you are using Trilinos/Epetra, the FOM state can be, e.g., an Epetra vector. Typically, <formula id="3">$y_{fom}$</formula> is a large (distributed) vector.</para>
</listitem><listitem><para><formula id="8">$\phi$</formula>: this is the matrix of the linear mapping (e.g. POD modes). Should be a data structure from your application. For example, if you are using Trilinos/Epetra, the FOM state can be, e.g., an Epetra MultiVector. Typically, <formula id="8">$\phi$</formula> is a large (distributed) matrix.</para>
</listitem><listitem><para><formula id="5">$y_{rom}$</formula>: this is the ROM state. ROM data strutures generally involve small, dense operators that fit well on a single node. In pressio, <emphasis>regardless of what the FOM types are</emphasis>, the ROM operators/data structures are either Eigen (always enabled) or Kokkos (optional dependency) types.</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="md_pages_tutorials_tutorial1_1autotoc_md51">
<title>Scenario A: your FOM types are natively supported in pressio</title>
<para>This case refers to data types which pressio knows how to manipulate and operate on. Examples include vector and matrix classes in Eigen, Epetra/Tpetra in Trilinos, or Kokkos views. What do we mean by <emphasis>natively supported</emphasis>? If you try to use a pressio functionality/class using data structure types that are already supported/known to pressio, pressio <emphasis>detects</emphasis> them, and automatically uses the (best) native kernels to perform computations. The full list of supported data structures types can be found [here]( <mcss:span xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-text m-danger">todo</mcss:span>).</para>
<para>Here, for demonstration purposes, we pretend the FOM uses Eigen types too. For other FOM types already known to pressio it would work similarly. The full tutorial can be found <ulink url="https://github.com/Pressio/pressio-tutorials/blob/master/tutorials/tutorial4.cc">here</ulink>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Running<sp/>tutorial<sp/>4\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>creating<sp/>a<sp/>linear<sp/>decoder<sp/>(or<sp/>mapping)<sp/>object<sp/>representing</highlight></codeline>
<codeline><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>yFom<sp/>=<sp/>phi<sp/>*<sp/>yRom</highlight></codeline>
<codeline><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>where<sp/>yFom<sp/>is<sp/>the<sp/>FOM<sp/>state,<sp/>yRom<sp/>is<sp/>the<sp/>reduced<sp/>state,</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>and<sp/>phi<sp/>is<sp/>a<sp/>matrix<sp/>(for<sp/>the<sp/>time<sp/>being,<sp/>assume<sp/>it<sp/>constant).</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>define<sp/>types<sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>native_fom_state_t<sp/>=<sp/>Eigen::VectorXd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>native_phi_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>Eigen::MatrixXd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>wrap<sp/>types<sp/>using<sp/>pressio<sp/>containers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>fom_state_t<sp/><sp/><sp/>=<sp/>pressio::containers::Vector&lt;native_fom_state_t&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>decoder_jac_t<sp/>=<sp/>pressio::containers::DenseMatrix&lt;native_phi_t&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>create<sp/>native<sp/>phi<sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>simplicity,<sp/>phi<sp/>is<sp/>filled<sp/>with<sp/>ones</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>native_phi_t<sp/>phiNative(6,<sp/>3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>phiNative.setConstant(1.);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>construct<sp/>decoder<sp/><sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>decoder_t<sp/>=<sp/>pressio::rom::LinearDecoder&lt;decoder_jac_t,<sp/>fom_state_t&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>by<sp/>moving<sp/>phiNative<sp/>(since<sp/>Eigen<sp/>supports<sp/>move<sp/>semantics)<sp/>we<sp/>avoid<sp/>a<sp/>deep<sp/>copy.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Note<sp/>that<sp/>after<sp/>the<sp/>move,<sp/>you<sp/>should<sp/>not<sp/>use<sp/>phiNative<sp/>directly.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>One<sp/>also<sp/>do<sp/>`decoderObj(phi)`<sp/>which<sp/>implies<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>matrix.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Obviously,<sp/>if<sp/>the<sp/>matrix<sp/>is<sp/>large<sp/>avoiding<sp/>a<sp/>copy<sp/>is<sp/>useful.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>decoder_t<sp/>decoder(std::move(phiNative));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>construct<sp/>reduced<sp/>state<sp/><sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>pressio<sp/>ROM<sp/>state<sp/>is<sp/>always<sp/>either<sp/>Eigen<sp/>or<sp/>Kokkos<sp/>(if<sp/>enabled)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>rom_state_t<sp/>=<sp/>pressio::containers::Vector&lt;Eigen::VectorXd&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rom_state_t<sp/>yRom(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>fill<sp/>with<sp/>2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pressio::ops::fill(yRom,<sp/>2.);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>apply<sp/>mapping<sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fom_state_t<sp/>yFom(6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>decoder.applyMapping(yRom,<sp/>yFom);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>check<sp/>solution<sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>yFom<sp/>should<sp/>be<sp/>=<sp/>[4.<sp/>4.<sp/>...,<sp/>4.]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;yFom.extent(0);<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;i=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>yFom(i)<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/>yFom(i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>expected<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>4.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="md_pages_tutorials_tutorial1_1autotoc_md52">
<title>Scenario B: your FOM types are NOT natively supported in pressio</title>
<para>This case refers to data types which pressio does <emphasis>not</emphasis> know how to manipulate and operate on. What do we mean by <emphasis>not natively supported</emphasis>? If you try to use a pressio functionality/class usign a data structure type that is <bold>NOT</bold> already supported/known to pressio, pressio <emphasis>detects/labels</emphasis> it as an <emphasis>arbitrary</emphasis> type, and you <bold>have to</bold> provide pressio with kernels to operate on these types.</para>
<para>Here, for demonstration, we pretend that:<itemizedlist>
<listitem><para><formula id="3">$y_{fom}$</formula> is a <computeroutput>std::vector&lt;&gt;</computeroutput></para>
</listitem><listitem><para><formula id="8">$\phi$</formula> is a <computeroutput>std::vector&lt;std::vector&lt;&gt;&gt;</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>Note that the code below would work for any other "arbitrary&apos;&apos; (not known to pressio) type, whether they are distributed or not. The full tutorial can be found <ulink url="https://github.com/Pressio/pressio-tutorials/blob/master/tutorials/tutorial5.cc">here</ulink>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*argv[])</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Running<sp/>tutorial<sp/>5\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>creating<sp/>a<sp/>linear<sp/>decoder<sp/>(or<sp/>mapping)<sp/>object<sp/>representing</highlight></codeline>
<codeline><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>yFom<sp/>=<sp/>phi<sp/>*<sp/>yRom</highlight></codeline>
<codeline><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>where<sp/>yFom<sp/>is<sp/>the<sp/>FOM<sp/>state,<sp/>yRom<sp/>is<sp/>the<sp/>reduced<sp/>state,</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/>and<sp/>phi<sp/>is<sp/>a<sp/>matrix<sp/>(for<sp/>the<sp/>time<sp/>being,<sp/>assume<sp/>it<sp/>constant).</highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>define<sp/>types<sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>FOM<sp/>application<sp/>uses<sp/>std::vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>scalar_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>double;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>native_fom_state_t<sp/>=<sp/>std::vector&lt;scalar_t&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>native_phi_t<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>std::vector&lt;std::vector&lt;scalar_t&gt;&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>wrapped<sp/>types</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>what<sp/>happens<sp/>in<sp/>pressio<sp/>when<sp/>we<sp/>wrap<sp/>native_fom_state_t<sp/>and<sp/>native_phi_t?</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Practically,<sp/>both<sp/>pressio::containers::Vector&lt;native_fom_state_t&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>and<sp/>pressio::containers::DenseMatrix&lt;native_fom_state_t&gt;<sp/>are<sp/>&quot;labeled&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>as<sp/>&quot;arbitrary&quot;<sp/>wrapper<sp/>types<sp/>for<sp/>which<sp/>pressio<sp/>does<sp/>not<sp/>know<sp/>how<sp/>to<sp/>operate<sp/>on.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>fom_state_t<sp/><sp/><sp/>=<sp/>pressio::containers::Vector&lt;native_fom_state_t&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>decoder_jac_t<sp/>=<sp/>pressio::containers::DenseMatrix&lt;native_phi_t&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>fill<sp/>phi<sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>native<sp/>phi<sp/>and<sp/>fill<sp/>with<sp/>ones</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>native_phi_t<sp/>phiNative(6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>&amp;<sp/>iRow<sp/>:<sp/>phiNative){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>iRow.resize(3,<sp/>1.);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>construct<sp/>decoder<sp/><sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Since<sp/>the<sp/>FOM<sp/>types<sp/>are<sp/>&quot;arbitrary&quot;,<sp/>we<sp/>need<sp/>to<sp/>declare<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>decoder<sp/>type<sp/>by<sp/>passing<sp/>as<sp/>a<sp/>template<sp/>argument<sp/>the<sp/>type<sp/>of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>class<sp/>(see<sp/>MyOps<sp/>struct<sp/>in<sp/>this<sp/>file)<sp/>containing<sp/>kernels<sp/>for<sp/>operating<sp/>on<sp/>the<sp/>data.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>And<sp/>we<sp/>need<sp/>to<sp/>pass<sp/>an<sp/>object<sp/>to<sp/>the<sp/>constructor<sp/>of<sp/>the<sp/>decoder</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>an<sp/>object<sp/>that<sp/>knows<sp/>how<sp/>to<sp/>compute<sp/>the<sp/>the<sp/>operations<sp/>needed.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>ops_t<sp/><sp/><sp/><sp/><sp/>=<sp/>MyOps&lt;scalar_t&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>decoder_t<sp/>=<sp/>pressio::rom::LinearDecoder&lt;decoder_jac_t,<sp/>fom_state_t,<sp/>ops_t&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>ops_t<sp/>ops;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>decoder_t<sp/>decoder(phiNative,<sp/>ops);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>construct<sp/>reduced<sp/>state<sp/><sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>use<sp/>Eigen<sp/>for<sp/>the<sp/>ROM<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>rom_state_t<sp/>=<sp/>pressio::containers::Vector&lt;Eigen::VectorXd&gt;;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>rom_state_t<sp/>yRom(3);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>fill<sp/>with<sp/>2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pressio::ops::fill(yRom,<sp/>2.);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>apply<sp/>mapping<sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>fom_state_t<sp/>yFom(6);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>decoder.applyMapping(yRom,<sp/>yFom);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>***<sp/>check<sp/>solution<sp/>***</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>yFom<sp/>should<sp/>be<sp/>=<sp/>[4.<sp/>4.<sp/>....<sp/>4.]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;6;<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;i=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>yFom(i)<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/><sp/>&lt;&lt;<sp/>yFom(i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>expected<sp/>=<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>4.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
</programlisting></para>
<sect2 id="md_pages_tutorials_tutorial1_1autotoc_md53">
<title>The ops struct</title>
<para>In order for pressio to handle the linear mapping, it needs to know how to operate on <formula id="8">$\phi$</formula>. To this end, in the code above, you need to pass to the <computeroutput>LinearDecoder</computeroutput> constructor an object to handle that computation. To compute the mapping, pressio will call the <computeroutput>product</computeroutput> method. <programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>scalar_t&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MyOps</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>z<sp/>=<sp/>beta*z<sp/>+<sp/>alpha<sp/>*<sp/>A<sp/>*<sp/>x</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>where<sp/>x<sp/>is<sp/>something<sp/>that<sp/>is<sp/>subscritable<sp/>as<sp/>x(i)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>x_t&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>product(pressio::nontranspose,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scalar_t<sp/>alpha,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;std::vector&lt;scalar_t&gt;&gt;<sp/>&amp;<sp/>A,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>x_t<sp/>&amp;<sp/>x,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scalar_t<sp/>beta,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;scalar_t&gt;<sp/>&amp;<sp/>z)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>obviously<sp/>not<sp/>efficient,<sp/>just<sp/>for<sp/>demonstration</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>i=0;<sp/>i&lt;A.size();<sp/>++i)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>+=<sp/>beta*z[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(std::size_t<sp/>j=0;<sp/>j&lt;A[i].size();<sp/>++j){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>z[i]<sp/>+=<sp/>alpha*A[i][j]*x(j);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="md_pages_tutorials_tutorial1_1autotoc_md54">
<title>Comments</title>
<para>We are constantly working increasing support in pressio for more external libraries. If you application types are not supported but you would like them to be, you can file an <ulink url="https://github.com/Pressio/pressio/issues">issue</ulink> to request it. </para>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
