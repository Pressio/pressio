<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="md_pages_components_rom_lspg_hypred" kind="page">
    <compoundname>md_pages_components_rom_lspg_hypred</compoundname>
    <title>rom: LSPG: hyper-reduced problem</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-note m-default" /></para>
<para><parblock><para>Defined in: <computeroutput>&lt;pressio/rom_lspg.hpp&gt;</computeroutput></para>
<para>Public namespace: <computeroutput>pressio::rom::lspg</computeroutput> </para>
</parblock></para>
<para><linebreak/>
</para>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-block m-warning" /></para>
<para><simplesect kind="par"><title>Prerequisite:</title><para>Before you read this page, make sure you read the <ulink url="md_pages_components_rom_lspg_unsteady.html">overall design idea of the unsteady LSPG</ulink>. </para>
</simplesect>
</para>
<sect1 id="md_pages_components_rom_lspg_hypred_1autotoc_md119">
<title>API</title>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>overload<sp/>for<sp/>continuous-time<sp/>systems</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">FomSystemType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">DecoderType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">RomStateType,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(1)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>FomReferenceStateType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>HypRedOperatorUpdaterType</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">ReturnType<sp/>create_hyperreduced_unsteady_problem(pressio::ode::StepScheme,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FomSystemType<sp/>&amp;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DecoderType<sp/>&amp;<sp/>,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>RomStateType<sp/>&amp;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FomReferenceStateType<sp/>&amp;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>HypRedOperatorUpdaterType<sp/>&amp;<sp/>hrUpdater)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>overload<sp/>for<sp/>discrete-time<sp/>systems</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::size_t<sp/>num_states,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">FomSystemType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">DecoderType,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">RomStateType,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(2)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>FomReferenceStateType</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&gt;</highlight></codeline>
<codeline><highlight class="normal">ReturnType<sp/>create_hyperreduced_unsteady_problem(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FomSystemType<sp/>&amp;<sp/>fomSysObj,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DecoderType<sp/>&amp;<sp/>decoder,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>RomStateType<sp/>&amp;<sp/>stateIn,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>FomReferenceStateType<sp/>&amp;<sp/>fomRef);</highlight></codeline>
</programlisting></para>
<sect2 id="md_pages_components_rom_lspg_hypred_1autotoc_md120">
<title>Parameters and Requirements</title>
<para><itemizedlist>
<listitem><para><computeroutput>FomSystemType</computeroutput>:<itemizedlist>
<listitem><para>your adapter class type specifying the FOM problem. <linebreak/>
</para>
</listitem><listitem><para>for 1: must satisfy the <ulink url="./md_pages_components_rom_fom_apis.html">continuous-time API</ulink></para>
</listitem><listitem><para>for 2: must satisfy the <ulink url="./md_pages_components_rom_fom_apis.html">discrete-time API</ulink></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><computeroutput>DecoderType</computeroutput>:<itemizedlist>
<listitem><para>decoder class type</para>
</listitem><listitem><para>must satify the requirements listed <ulink url="md_pages_components_rom_decoder.html">here</ulink></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><computeroutput>RomStateType</computeroutput>:<itemizedlist>
<listitem><para>currently, it must be either an Eigen vector or a Kokkos 1D view</para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><computeroutput>FomReferenceStateType</computeroutput>:<itemizedlist>
<listitem><para>your FOM reference state that is used when reconstructing the FOM state</para>
</listitem><listitem><para>must be copy-constructible and the following must be true:<linebreak/>
 <programlisting filename=".cpp"><codeline><highlight class="normal">std::is_same&lt;FomReferenceStateType,<sp/>typename<sp/>DecoderType::fom_state_type&gt;::value<sp/>==<sp/></highlight><highlight class="keyword">true</highlight></codeline>
</programlisting></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><computeroutput>HypRedOperatorUpdaterType</computeroutput>:<itemizedlist>
<listitem><para>an instance of class that knows how to update operands that live on the stencil and sample mesh.</para>
</listitem><listitem><para>Must meet the following interface:</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">HypRedUpdater</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>operand_type1<sp/>=<sp/></highlight><highlight class="comment">/*should<sp/>be<sp/>the<sp/>type<sp/>of<sp/>your<sp/>fom<sp/>velocity*/</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>operand_type2<sp/>=<sp/></highlight><highlight class="comment">/*should<sp/>be<sp/>the<sp/>type<sp/>of<sp/>your<sp/>decoder&apos;s<sp/>jacobian*/</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>ScalarType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>updateSampleMeshOperandWithStencilMeshOne(operand_type1<sp/>&amp;<sp/>operand_on_sample,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ScalarType<sp/>alpha,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>operand_type1<sp/>&amp;<sp/>operand_on_stencil,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ScalarType<sp/>beta)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>appropriately<sp/>compute:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>operand_on_sample<sp/>=<sp/>alpha*operand_on_sample<sp/>+<sp/>beta*operand_on_stencil</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>ScalarType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>updateSampleMeshOperandWithStencilMeshOne(operand_type2<sp/>&amp;<sp/>operand_on_sample,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ScalarType<sp/>alpha,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>operand_type2<sp/>&amp;<sp/>operand_on_stencil,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ScalarType<sp/>beta)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>appropriately<sp/>compute:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>operand_on_sample<sp/>=<sp/>alpha*operand_on_sample<sp/>+<sp/>beta*operand_on_stencil</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para><itemizedlist>
<listitem><para><computeroutput>num_states</computeroutput>:<itemizedlist>
<listitem><para><emphasis>total</emphasis> number of states you need to use (must be &lt;= 3), if you need more open issue</para>
</listitem><listitem><para>only needed for the discrete-time case</para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para><linebreak/>
</para>
</sect2>
</sect1>
<sect1 id="md_pages_components_rom_lspg_hypred_1autotoc_md121">
<title>Why do we need the HypRedUpdater?</title>
<para>When working with a hyper-reduced problem, pressio has to manipulate objects that have different sizes/distributions. For this problem variant, in fact, some operators are naturally defined on the what we refer to as &quot;sample mesh&quot; while some are defined on what we call the &quot;stencil mesh&quot;.</para>
<para>As explained <ulink url="https://pressio.github.io/algos/hyper/">here</ulink>, recall that:</para>
<para><orderedlist>
<listitem><para><bold>sample mesh</bold>: a disjoint collection of elements where the velocity (or residual) operator is computed.</para>
</listitem><listitem><para><bold>stencil mesh</bold>: the set of all nodes or elements needed to compute the velocity or residual on the sample mesh.</para>
</listitem><listitem><para>Typically, the sample mesh is a subset of the stencil mesh.</para>
</listitem></orderedlist>
</para>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-note m-info" /></para>
<para><parblock><para>The <computeroutput>hrUpdater</computeroutput> is an object that knows how to compute <computeroutput>a*x + b*y</computeroutput> for operands <computeroutput>x,y,</computeroutput> that (potentially) do NOT have the same size/data distribution since they are defined on stencil and sample mesh. </para>
</parblock></para>
<sect2 id="md_pages_components_rom_lspg_hypred_1autotoc_md122">
<title>Explain it to me better!</title>
<para>Suppose that your FOM problem involves a 2D problem and that your FOM numerical method needs at every cell information from the nearest neighbors. For the sake of explanation, <emphasis>it does not matter what problem we are solving</emphasis>, only what we just said. Now, suppose that you want to try hyper-reduced LSPG on it. You come up with a sample and stencil mesh for your problem (read <ulink url="https://pressio.github.io/algos/hyper/">this page</ulink> for some information about how to select sample mesh cells), and let&apos;s say it looks like this: <image type="html" name="lspg_sample_mesh1.png" width="400px"></image>
</para>
<para>The stencil mesh is the set of <emphasis>all</emphasis> cells shown, while the sample mesh is the <emphasis>subset</emphasis> color-coded yellow. We have added an arbitrary enumeration scheme to uniquely assign a global index to each cell. The enumeration order does not matter, this is just for demonstration purposes. You have an adapter class for your problem that is able to compute the FOM right-hand-side <formula id="4">$f$</formula> on the yellow cells, for a given FOM state <formula id="3">$y$</formula> on the stencil mesh.</para>
<para>For this example, you would need to create an <computeroutput>HypRedUpdater</computeroutput> object capable of performing those operations on operands that defined on the visualized sample and stencil meshes.</para>
<para> <mcss:span xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-text m-danger">todo</mcss:span>: explain that this is application-specific. There is nothing we can be to make this simple for generic applications, but we can simplify this for shared-mem ones and users can fully omit this for Trilinos based applications since we can use the underlying maps to figure out how to combine operators. </para>
</sect2>
</sect1>
    </detaileddescription>
    <location file="pages/components/rom_lspg_hypred.md"/>
  </compounddef>
</doxygen>
