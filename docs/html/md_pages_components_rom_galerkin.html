<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>rom: Galerkin: high-level details | Pressio|C++</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <a href="index.html" id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">Pressio|C++</a>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-12 m-col-m-none">
            <li><a href="md_pages_introduction.html">Introduction</a></li>
            <li><a href="md_pages_installation.html">Installation</a></li>
            <li>
              <a>Documentation/A</a>
              <ol>
                <li><a href="md_pages_components_mpl.html">mpl</a></li>
                <li><a href="md_pages_components_utils.html">utils</a></li>
                <li><a href="md_pages_components_type_traits.html">type_traits</a></li>
                <li><a href="md_pages_components_expressions.html">expressions</a></li>
                <li><a href="md_pages_components_ops.html">ops</a></li>
                <li><a href="md_pages_components_qr.html">qr</a></li>
                <li><a href="md_pages_components_linsolvers.html">linear solvers</a></li>
                <li><a> nonlinear solvers: </a></li>
                <li><a href="md_pages_components_nonlinsolvers_general.html"> &emsp; - general info</a></li>
                <li><a href="md_pages_components_nonlinsolvers_system_api.html"> &emsp; - problem class API</a></li>
                <li><a href="md_pages_components_nonlinsolvers_nr.html"> &emsp; - Newton-Raphson</a></li>
                <li><a href="md_pages_components_nonlinsolvers_gn.html"> &emsp; - Gauss-Newton</a></li>
                <li><a href="md_pages_components_nonlinsolvers_lm.html"> &emsp; - Levenberg-Marquardt</a></li>
                <li><a href="md_pages_components_nonlinsolvers_irls.html"> &emsp; - irls</a></li>
                <li><a> ode: </a></li>
                <li><a href="md_pages_components_ode_advance.html"> &emsp; - advancers</a></li>
                <li><a href="md_pages_components_ode_steppers_explicit.html"> &emsp; - explicit steppers</a></li>
                <li><a href="md_pages_components_ode_steppers_implicit.html"> &emsp; - implicit steppers</a></li>
              </ol>
            </li>
            <li>
              <a>Documentation/B</a>
              <ol>
                <li><a> rom: </a></li>
                <li><a href="md_pages_components_rom_fom_apis.html"> &emsp; - FOM adapter API</a></li>
                <li><a href="md_pages_components_rom_decoder.html">  &emsp; - decoder</a></li>
                <li><a href="md_pages_components_rom_galerkin.html"> &emsp; - Galerkin </a></li>
                <li><a href="md_pages_components_rom_galerkin_default.html"> &emsp; &emsp; - default problem </a></li>
                <li><a href="md_pages_components_rom_galerkin_hypred.html"> &emsp; &emsp; - hyper-reduced problem </a></li>
                <li><a href="md_pages_components_rom_galerkin_masked.html"> &emsp; &emsp; - masked problem </a></li>
                <li><a href="md_pages_components_rom_lspg_steady.html"> &emsp; - LSPG: steady </a></li>
                <li><a href="md_pages_components_rom_lspg_default_steady.html"> &emsp; &emsp; - default problem </a></li>
                <li><a href="md_pages_components_rom_lspg_hypred_steady.html"> &emsp; &emsp; - hyper-reduced problem </a></li>
                <li><a href="md_pages_components_rom_lspg_masked_steady.html"> &emsp; &emsp; - masked problem </a></li>
                <li><a href="md_pages_components_rom_lspg_unsteady.html"> &emsp; - LSPG: unsteady </a></li>
                <li><a href="md_pages_components_rom_lspg_default.html"> &emsp; &emsp; - default problem </a></li>
                <li><a href="md_pages_components_rom_lspg_hypred.html"> &emsp; &emsp; - hyper-reduced problem </a></li>
                <li><a href="md_pages_components_rom_lspg_masked.html"> &emsp; &emsp; - masked problem </a></li>
                <li><a href="md_pages_components_rom_wls.html">rom: WLS</a></li>
              </ol>
            </li>
            <li><a href="https://pressio.github.io/pressio-tutorials">Tutorials</a></li>
            <li><a href="https://github.com/Pressio/pressio">Github</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="7">
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          rom: Galerkin: high-level details
        </h1>
<div class="m-note m-info"><p>This page explains the API for using the pressio Galerkin ROMs. After reading this, you should understand what a &quot;pressio Galerkin problem&quot; is, the variants we currently support, and how to use the problem after instantiating it.</p><p>If anything is unclear, and/or you have suggestions on how to improve this page, <a href="https://github.com/Pressio/pressio/issues">open an issue on github</a>.</p></div><p><br /></p><section id="autotoc_md90"><h2><a href="#autotoc_md90">Everything starts with creating a problem!</a></h2><p>The main entry point to use the pressio Galerkin ROMs is the problem class. You create an instance of one of the supported &quot;Galerkin problems&quot; as:</p><aside class="m-block m-primary"><pre class="m-code"><span class="k">namespace</span> <span class="n">pgal</span>    <span class="o">=</span> <span class="n">pressio</span><span class="o">::</span><span class="n">rom</span><span class="o">::</span><span class="n">galerkin</span><span class="p">;</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">scheme</span> <span class="o">=</span> <span class="n">pressio</span><span class="o">::</span><span class="n">ode</span><span class="o">::</span><span class="n">StepScheme</span><span class="o">::</span><span class="n">some_value</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">problem</span>      <span class="o">=</span> <span class="n">pgal</span><span class="o">::</span><span class="n">create_</span><span class="o">&lt;</span><span class="n">keywords</span><span class="o">&gt;</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="cm">/* args */</span> <span class="p">);</span></pre></aside><p>where <code>&lt;keywords&gt;</code> express the variant you want (more below), <code>some_value</code> is an enum value to select the time stepping scheme (e.g., explicit Euler, RK4, BDF1, etc), and <code>args</code> are the arguments needed which depend on the variant you choose.</p><p>We currently offer the following variants:</p><div class="m-button m-success"><a href="md_pages_components_rom_galerkin_default.html"><div class="m-medium">&ensp;&emsp;Default Problem&emsp; &ensp;</div>  <div class="m-small">click to learn more</div></a></div><div class="m-button m-primary"><a href="md_pages_components_rom_galerkin_hypred.html"><div class="m-medium">Hyper-reduced Problem</div>  <div class="m-small">click to learn more</div></a></div><div class="m-button m-warning"><a href="md_pages_components_rom_galerkin_masked.html"><div class="m-medium">&ensp;&emsp; Masked Problem&ensp;&emsp;</div>  <div class="m-small">click to learn more</div></a></div></section><section id="autotoc_md91"><h2><a href="#autotoc_md91">Problem class API</a></h2><p>A Galerkin problem exposes different methods depending on whether you choose an explicit of implicit scheme. Below we discuss both scenarios.</p><section id="autotoc_md92"><h3><a href="#autotoc_md92">Explicit case</a></h3><p>If you create an explicit Galerkin problem, the problem exposes the following API:</p><pre class="m-code"><span class="k">class</span> <span class="nc">ExplicitGalerkinProblemClass</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">traits</span> <span class="o">=</span> <span class="cm">/* nested typedef to access the problem&#39;s traits */</span><span class="p">;</span>

  <span class="c1">// const ref to the object knowing how to reconstruct a FOM state</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">fomStateReconstructor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TimeType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">StepCount</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">galerkin_state_type</span> <span class="o">&amp;</span> <span class="n">state</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">TimeType</span> <span class="n">current_time</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">TimeType</span> <span class="n">time_step_size_to_use</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">StepCount</span> <span class="n">step_count</span><span class="p">);</span>
<span class="p">};</span></pre><aside class="m-block m-success"><h3>Main thing to remember:</h3><p>An explicit Galerkin problem satisfies the <a href="md_pages_components_ode_advance.html">steppable concept</a> (specifically, behaves like an <a href="md_pages_components_ode_steppers_explicit.html">explicit stepper</a>).</p></aside><p>If needed, the traits class contains:</p><pre class="m-code"><span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">fom_system_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">scalar_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">decoder_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">decoder_jac_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">galerkin_state_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">galerkin_velocity_type</span><span class="p">;</span></pre></section><section id="autotoc_md93"><h3><a href="#autotoc_md93">Implicit case</a></h3><p>If you create an implicit Galerkin problem, the problem exposes the following API:</p><pre class="m-code"><span class="k">class</span> <span class="nc">ImplicitGalerkinProblemClass</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">traits</span> <span class="o">=</span> <span class="cm">/* nested typedef to access the problem&#39;s traits */</span><span class="p">;</span>

  <span class="k">using</span> <span class="n">scalar_type</span>    <span class="o">=</span> <span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">scalar_type</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">state_type</span>     <span class="o">=</span> <span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">galerkin_state_type</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">residual_type</span>  <span class="o">=</span> <span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">galerkin_residual_type</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">jacobian_type</span>  <span class="o">=</span> <span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">galerkin_jacobian_type</span><span class="p">;</span>

  <span class="c1">// const ref to the object knowing how to reconstruct a FOM state</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">fomStateReconstructor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TimeType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">StepCount</span><span class="p">,</span> <span class="k">class</span> <span class="nc">SolverType</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">galerkin_state_type</span> <span class="o">&amp;</span> <span class="n">state</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">TimeType</span> <span class="n">current_time</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">TimeType</span> <span class="n">time_step_size_to_use</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">StepCount</span> <span class="n">step_count</span><span class="p">,</span>
                  <span class="n">SolverType</span> <span class="o">&amp;</span> <span class="n">solver</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// NOTE: here we reveal a bit of how operator() works.</span>
    <span class="c1">// This is on purpose so that some things below will be more clear.</span>

    <span class="c1">// The operator() has 3 main stages:</span>
    <span class="c1">// 1. we prepare for doing a step by setting/updating what is needed</span>

    <span class="c1">// 2. call solver (which will query operators)</span>
    <span class="n">solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>

    <span class="c1">// 3. we do some other things to end the step</span>
  <span class="p">}</span>

  <span class="n">residual_type</span> <span class="n">createResidual</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">jacobian_type</span> <span class="nf">createJacobian</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">residual</span><span class="p">(</span><span class="k">const</span> <span class="n">state_type</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">residual_type</span> <span class="o">&amp;</span> <span class="n">res</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">jacobian</span><span class="p">(</span><span class="k">const</span> <span class="n">state_type</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">jacobian_type</span> <span class="o">&amp;</span> <span class="n">jac</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span></pre><aside class="m-block m-success"><h3>Main thing to remember:</h3><p>An implicit Galerkin problem satisfies the <a href="md_pages_components_ode_advance.html">steppable concept</a> (specifically, behaves like an <a href="md_pages_components_ode_steppers_implicit.html">implicit stepper</a>).</p></aside><p>The traits contain:</p><pre class="m-code"><span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">fom_system_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">scalar_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">decoder_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">decoder_jac_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">galerkin_state_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">galerkin_residual_type</span><span class="p">;</span>
<span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">galerkin_jacobian_type</span><span class="p">;</span></pre><p><br /></p><hr/>
 <p><br /></p></section></section><section id="autotoc_md94"><h2><a href="#autotoc_md94">How do I use an EXPLICIT problem?</a></h2><p>See the following:</p><pre class="m-code"><span class="k">namespace</span> <span class="n">pode</span> <span class="o">=</span> <span class="n">pressio</span><span class="o">::</span><span class="n">ode</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">pgal</span> <span class="o">=</span> <span class="n">pressio</span><span class="o">::</span><span class="n">rom</span><span class="o">::</span><span class="n">galerkin</span><span class="p">;</span>

<span class="k">const</span> <span class="k">auto</span> <span class="n">scheme</span> <span class="o">=</span> <span class="n">pdoe</span><span class="o">::</span><span class="nl">StepScheme</span><span class="p">:</span><span class="n">ForwardEuler</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">problem</span>      <span class="o">=</span> <span class="n">pgal</span><span class="o">::</span><span class="n">create_default_explicit_problem</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="cm">/* args */</span><span class="p">);</span>

<span class="c1">// we assume a galState exists</span>

<span class="c1">// you can take a single step of the problem</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="n">problem</span><span class="p">(</span><span class="n">galState</span><span class="p">,</span> <span class="n">currentTime</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c1">// or you can define your own stepping loop</span>
<span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">step</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">step</span><span class="o">++</span><span class="p">){</span>
 <span class="n">problem</span><span class="p">(</span><span class="n">galState</span><span class="p">,</span> <span class="n">currentTime</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
 <span class="n">currentTime</span> <span class="o">+=</span> <span class="n">dt</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// or you can use our own functions to advance the problem</span>
<span class="n">pode</span><span class="o">::</span><span class="n">advance_n_steps</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="cm">/* args */</span><span class="p">);</span>

<span class="c1">// or</span>
<span class="n">pode</span><span class="o">::</span><span class="n">advance_n_steps_and_observe</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="cm">/* args */</span><span class="p">);</span>

<span class="c1">// or others</span></pre><p><br /></p></section><section id="autotoc_md95"><h2><a href="#autotoc_md95">How do I use an IMPLICIT problem?</a></h2><p>Recall that doing implicit time stepping it is not as simple as explicit. <a href="md_pages_components_ode_steppers_implicit.html">For implicit, in fact, you also need a <em>solver</em> to compute the solution at the next step</a>. In the case of Galerkin, you can use a Newton-Raphson solver, because at eaach step, you are solving a (reduced) system of equations with as many equations as the number of unknowns. More specifically, the system you need to solve has as many equations as the dimensionality of your approximating subspace. See some sample snippets below:</p><pre class="m-code"><span class="k">namespace</span> <span class="n">psolvers</span> <span class="o">=</span> <span class="n">pressio</span><span class="o">::</span><span class="n">nonlinearsolvers</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">pode</span>     <span class="o">=</span> <span class="n">pressio</span><span class="o">::</span><span class="n">ode</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">pgal</span>     <span class="o">=</span> <span class="n">pressio</span><span class="o">::</span><span class="n">rom</span><span class="o">::</span><span class="n">galerkin</span><span class="p">;</span>

<span class="k">const</span> <span class="k">auto</span> <span class="n">scheme</span> <span class="o">=</span> <span class="n">pdoe</span><span class="o">::</span><span class="nl">StepScheme</span><span class="p">:</span><span class="n">BDF1</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">problem</span>      <span class="o">=</span> <span class="n">pgal</span><span class="o">::</span><span class="n">create_default_implicit_problem</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="cm">/* args */</span><span class="p">);</span>

<span class="c1">// we assume a galState exists</span>

<span class="c1">// for example, using the pressio solver</span>
<span class="k">auto</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">psolvers</span><span class="o">::</span><span class="n">create_newton_rapshon</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="cm">/* args */</span><span class="p">);</span>

<span class="c1">// you can take a single step of the problem</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="n">problem</span><span class="p">(</span><span class="n">galState</span><span class="p">,</span> <span class="n">currentTime</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">solver</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// or you can define your own stepping loop</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">step</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">step</span><span class="o">++</span><span class="p">){</span>
   <span class="n">problem</span><span class="p">(</span><span class="n">galState</span><span class="p">,</span> <span class="n">currentTime</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">solver</span><span class="p">);</span>
   <span class="n">currentTime</span> <span class="o">+=</span> <span class="n">dt</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// or you can use our own functions to advance the problem</span>
<span class="n">pode</span><span class="o">::</span><span class="n">advance_n_steps_and_observe</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="cm">/* args */</span><span class="p">,</span> <span class="n">solver</span><span class="p">);</span></pre><section id="autotoc_md96"><h3><a href="#autotoc_md96">Using a custom solver</a></h3><p>In the snippet above, we show how to use the pressio Newton-Raphson solver to solve the Galerkin problem. If you want to use your own solver, you can do that! Here we discuss how.</p><pre class="m-code"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">R_type</span><span class="p">,</span> <span class="k">class</span> <span class="nc">J_type</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">CustomSolver</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">R_type</span> <span class="n">m_R</span><span class="p">;</span>
  <span class="n">J_type</span> <span class="n">m_J</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ProblemType</span><span class="o">&gt;</span>
  <span class="n">CustomSolver</span><span class="p">(</span><span class="n">ProblemType</span> <span class="o">&amp;</span> <span class="n">system</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">m_R</span><span class="p">(</span><span class="n">system</span><span class="p">.</span><span class="n">createResidual</span><span class="p">()),</span>
      <span class="n">m_J</span><span class="p">(</span><span class="n">system</span><span class="p">.</span><span class="n">createJacobian</span><span class="p">())</span>
  <span class="p">{}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">ProblemType</span><span class="p">,</span> <span class="k">class</span> <span class="nc">StateType</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">solve</span><span class="p">(</span><span class="n">ProblemType</span> <span class="o">&amp;</span> <span class="n">problem</span><span class="p">,</span> <span class="n">StateType</span> <span class="o">&amp;</span> <span class="n">state</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// the problem object is the instance of the Galerkin problem you chose.</span>
    <span class="c1">// You can compute residual, Jacobian, etc and solve as you wish</span>
    <span class="c1">// for instance, you can do:</span>

    <span class="k">for</span> <span class="p">(</span><span class="cm">/* some loop or whatever your solver needs */</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">problem</span><span class="p">.</span><span class="n">residual</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">m_R</span><span class="p">);</span>
      <span class="n">problem</span><span class="p">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">m_J</span><span class="p">);</span>
      <span class="c1">// do something with the residual (m_R) and Jacobian (m_J)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">namespace</span> <span class="n">pode</span>     <span class="o">=</span> <span class="n">pressio</span><span class="o">::</span><span class="n">ode</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">pgal</span>     <span class="o">=</span> <span class="n">pressio</span><span class="o">::</span><span class="n">rom</span><span class="o">::</span><span class="n">galerkin</span><span class="p">;</span>

<span class="k">const</span> <span class="k">auto</span> <span class="n">scheme</span> <span class="o">=</span> <span class="n">pdoe</span><span class="o">::</span><span class="nl">StepScheme</span><span class="p">:</span><span class="n">BDF1</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">problem</span>      <span class="o">=</span> <span class="n">pgal</span><span class="o">::</span><span class="n">create_default_implicit_problem</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="cm">/* args */</span><span class="p">);</span>
<span class="k">using</span> <span class="n">traits</span>      <span class="o">=</span> <span class="k">typename</span> <span class="nc">decltype</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span><span class="o">::</span><span class="nl">traits</span><span class="p">:</span>

<span class="c1">// instantiate your own solver</span>
<span class="c1">// and you can use it like shown above</span>
<span class="k">using</span> <span class="n">gal_R_type</span>  <span class="o">=</span> <span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">galerkin_residual_type</span><span class="p">;</span>
<span class="k">using</span> <span class="n">gal_J_type</span>  <span class="o">=</span> <span class="k">typename</span> <span class="nc">traits</span><span class="o">::</span><span class="n">galerkin_jacobian_type</span><span class="p">;</span>
<span class="n">CustomSolver</span><span class="o">&lt;</span><span class="n">gal_R_type</span><span class="p">,</span> <span class="n">gal_J_type</span><span class="o">&gt;</span> <span class="n">yourSolver</span><span class="p">(</span><span class="n">problem</span><span class="p">);</span>

<span class="c1">// we assume a galState exists</span>

<span class="c1">// you can take a single step of the problem</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
  <span class="n">problem</span><span class="p">(</span><span class="n">galState</span><span class="p">,</span> <span class="n">currentTime</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">yourSolver</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// or you can define your own stepping loop</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">currentTime</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">step</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">step</span><span class="o">++</span><span class="p">){</span>
   <span class="n">problem</span><span class="p">(</span><span class="n">galState</span><span class="p">,</span> <span class="n">currentTime</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">yourSolver</span><span class="p">);</span>
   <span class="n">currentTime</span> <span class="o">+=</span> <span class="n">dt</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// or you can use our own functions to advance the problem</span>
<span class="n">pode</span><span class="o">::</span><span class="n">advance_n_steps_and_observe</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="cm">/* args */</span><span class="p">,</span> <span class="n">yourSolver</span><span class="p">);</span></pre><aside class="m-block m-warning"><h3>Pay attention to:</h3><p>If you need fine-grained access, i.e., you need to make the problem take a single step (in other words you don&#x27;t use our own <code>advance</code> methods), you should <em>always</em> just rely on <code>operator()</code>. To be more explicit, look at this snippet:</p><pre class="m-code"><span class="c1">// ...</span>
<span class="c1">// assume we have a galState</span>
<span class="k">auto</span> <span class="n">problem</span>      <span class="o">=</span> <span class="n">pgal</span><span class="o">::</span><span class="n">create_default_implicit_problem</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="cm">/* args */</span><span class="p">);</span>
<span class="n">solver</span> <span class="o">=</span> <span class="c1">// create solver somehow</span>

<span class="c1">// !!! You should NOT do this, this is undefined behavior !!!</span>
<span class="n">solver</span><span class="p">.</span><span class="n">solve</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">galState</span><span class="p">)</span>

<span class="c1">// You should do this:</span>
<span class="n">problem</span><span class="p">(...,</span> <span class="n">solver</span><span class="p">);</span>
<span class="c1">// or, better, rely on (the advance functions do the right thing behind the scenes)</span>
<span class="n">pode</span><span class="o">::</span><span class="n">advance_n_steps_and_observe</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="cm">/* args */</span><span class="p">,</span> <span class="n">solver</span><span class="p">);</span></pre></aside><p><br /></p><hr/>
 <p><br /></p></section></section><section id="autotoc_md97"><h2><a href="#autotoc_md97">Why does a Galerkin problem behave like a stepper?</a></h2><p>The answer is that practically speaking, at the lowest-level, a Galerkin problem can be reduced to simply a &quot;custom&quot; stepper to advance in time. This is how pressio implements this and the reason why a Galerkin problem contains a stepper object inside: when you create the problem, pressio creates the appropriate custom stepper object that you can use. You don&#x27;t need to know how this is done, or rely on the details, because these are problem- and implementation-dependent, and we reserve the right to change this in the future. All you need to know is that a an explicit Galerkin problem behaves like a an explicit stepper, and an implicit Galerkin problem behaves like an implicit stepper.</p></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Pressio|C++. Created with <a href="https://doxygen.org/">Doxygen</a> 1.9.1 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
