.. role:: raw-html-m2r(raw)
   :format: html

.. include:: ../../mydefs.rst


``SystemWithResidualAndJacobian``
=================================

Syntax only
-----------

.. code-block:: cpp

   struct Something
   {
     using state_type     = /* your type */;
     using residual_type  = /* your type */;
     using jacobian_type  = /* your type */;

     state_type    createState() const;
     residual_type createResidual() const;
     jacobian_type createJacobian() const;
     void residual(const state_type& x, residual_type & res) const;
     void jacobian(const state_type& x, jacobian_type & jac) const;
   };


..
   Full concept
   ------------

   .. code-block:: cpp

       template <class T>
       concept SystemWithResidualAndJacobian =
	 //
	 // purely syntactic requirements
	 //
	 requires(){
	   requires std::copy_constructible<typename T::state_type>;
	   requires std::copy_constructible<typename T::residual_type>;
	   requires std::copy_constructible<typename T::jacobian_type>;
	 } &&
	 // creation methods
	 requires(const T & A){
	   { A.createState()    } -> std::same_as<typename T::state_type>;
	   { A.createResidual() } -> std::same_as<typename T::residual_type>;
	   { A.createJacobian() } -> std::same_as<typename T::jacobian_type>;
	 } &&
	 // evaluation methods
	 requires(const T & A, const typename T::state_type & s,
		  typename T::residual_type & r,
		  typename T::jacobian_type & j){
	   A.residual(s, r);
	   A.jacobian(s, j);
	 } &&

	 //
	 // execution/language axioms
	 //
	 axiom NonAliasingOperators(const T & A){
	  auto s1 = A.createState();
	  auto s2 = A.createState();
	  std::addressof(s1) != std::addressof(s2);

	  auto r1 = A.createResidual();
	  auto r2 = A.createResidual();
	  std::addressof(r1) != std::addressof(r2);

	  auto j1 = A.createJacobian();
	  auto j2 = A.createJacobian();
	  std::addressof(j1) != std::addressof(j2);
	 } &&
	 //
	 axiom Deterministic(const T & A,
			     const typename T::state_type & s1,
			     const typename T::state_type & s2,
			     typename T::residual_type & r1,
			     typename T::residual_type & r2,
			     typename T::jacobian_type & j1,
			     typename T::jacobian_type & j2)
	 {
	   // the C++ standard actually names Deterministic as EqualityPreserving
	   A.residual(s1, r1);
	   A.residual(s2, r2);
	   A.jacobian(s1, j1);
	   A.jacobian(s2, j2);
	   (s1==s2) && => r1==r2, j1==j2;
	 } &&
	 axiom BlockingOperations(){
	   // all methods are blocking (allocations/operations complete before returning)
	 } &&
	 axiom ConstCorrectness(){
	   // const qualification is preserved, methods do NOT modify const arguments
	 } &&

	 //
	 // mathematical axioms
	 //
	 requires(){
	   requires RealVectorSpaceElement<typename T::state_type>;
	   requires RealVectorSpaceElement<typename T::residual_type>;
	   requires RealVectorSpaceElement<typename T::jacobian_type>;
	 } &&
	 axiom RootFindingFormulation(){
	   // residual evaluation represents the computation of R(x) = 0
	 } &&
	 axiom NonSingularJacobian(){
	   // the jacobian is supposed to be non-singular, Jv=b is well-posed
	 } &&
	 axiom DifferentiableResidual(){
	   // residual function is supposed to be differentiable
	 };


.. Deterministic is very similar to discussion in Sutton 2012 about functional: "To resolve these design problems, we define two static constraints for building func- tional abstractions: Callable and Procedure. The Callable constraint determines whether or not a type can be invoked as a function over a sequence of argument types. The Proce- dure constraint establishes the basic type requirements for all procedural and functional abstractions."

..  ``DeterminedSystemWithResidualAndJacobian``
   ===========================================

   .. code-block:: cpp

       template <class T>
       concept DeterminedSystemWithResidualAndJacobian =
	 SystemWithResidualAndJacobian<T> &&
	 axiom Determined(){
	   // dimension of the residual vector space == dimension of the state vector space
	   // i.e. # of equations is same as # of unknowns
	 };

   ``OverdeterminedSystemWithResidualAndJacobian``
   ===============================================

   .. code-block:: cpp

       template <class T>
       concept OverdeterminedSystemWithResidualAndJacobian =
	 SystemWithResidualAndJacobian<T> &&
	 axiom Overdetermined(){
	   // dimension of the residual vector space > dimension of the state vector space
	   // i.e. # of equations > # of unknowns
	 };
