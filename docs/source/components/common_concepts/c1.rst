
``VectorSpaceElement``
======================

.. requires(T & u, const T & v, const T & w){
   // u = v + w
   pressio::ops::update(u, v, w);
   // u = a*u
   typename pressio::Traits<T>::scalar_type a{};
   pressio::ops::scale(u, a);
   }

The concept ``VectorSpaceElement`` specifies that a type ``T``
represents an element of a `vector space <https://en.wikipedia.org/wiki/Vector_space>`_
:math:`V` defined on a field :math:`F`.

.. code-block:: cpp

    template <class T>
    concept VectorSpaceElement =
      requires(){
        // the trait specialization AND scalar_type have to exists
        typename pressio::Traits<T>::scalar_type;
      } &&
      axiom ScalarTypeRepresentsTheFieldScalar(){
       // scalar_type represents the scalar type of the field F on which the space is defined
      } &&
      axiom AdditiveClosure(const T& v, const T& w){
        // v + w is defined and belongs to same vector space
      } &&
      axiom ScalarMultiplicationClosure(const T& v,
                                        typename pressio::Traits<T>::scalar_type a){
       // av is defined and belongs to same space
      } &&
      axiom Associativity(const T& u, const T& v, const T& w){
        // u + (v + w) = (u + v) + w
      } &&
      axiom Commutativity(const T& u, const T& v){
        // u + v = v + u
      } &&
      axiom IdentityElement(const T& v){
        // there exits a zero-element "0 \in V" such that: v + 0 = v
      } &&
      axiom InverseElement(const T& v){
        // there exists an element -v such that: v + (âˆ’v) = 0 (the zero-element)
      } &&
      axiom ScalarCompatibility(const T& v,
                                typename pressio::Traits<T>::scalar_type a,
                                typename pressio::Traits<T>::scalar_type b){
        // a(bv) = (ab)v
      } &&
      axiom ScalarMultiplicationIdentity(const T& v){
       // 1v = v where 1 is the multiplicative identity in F
      } &&
      axiom DitributivityWrtVectorAddition(const T& u,
                                           const T& v,
                                           typename pressio::Traits<T>::scalar_type a,
                                           typename pressio::Traits<T>::scalar_type b){
       // a(u + v) = au + av
      } &&
      axiom DitributivityWrtFieldAddition(const T& v,
                                          typename pressio::Traits<T>::scalar_type a,
                                          typename pressio::Traits<T>::scalar_type b){
       // (a + b)v = av + bv
      };


``RealVectorSpaceElement``
===========================

The concept ``RealVectorSpaceElement`` specifies that a type ``T``
represents an element of a `vector space <https://en.wikipedia.org/wiki/Vector_space>`_
:math:`V` defined on the field of **real numbers**, i.e., :math:`F = \mathbb{R}`.

.. code-block:: cpp

    template <class T>
    concept RealVectorSpaceElement =
       VectorSpaceElement<T> &&
       axiom DefinedOnTheFieldOfRealNumbers(){
         // the vector space is defined on the field of real numbers,
         // which means that the scalar_type of T must represent a real number
      };


Note that here the requirement of the field being the real numbers
is left as an axiom. One could statically check if the ``scalar_type``
is a floating point which would be a good approximation.
But that would prevent one from using a different type that still
semantically represents a real number.

.. ``ComplexVectorSpaceElement``
   --------------------------------

   .. code-block:: cpp

       template <class T>
       concept ComplexVectorSpaceElement = VectorSpaceElement<T>;
    // axiom: the vector space is defined on the field of complex numbers

   One could actually check if the scalar_type is a ``std::complex``
   but that prevents one from using a different type that still
   semantically represents a complex number, for example a different impl of complex.


   ``VectorSpaceElementsWithSameField``
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   .. code-block:: cpp

       template <class T1, class T2>
       concept VectorSpaceElementsWithSameField =
	 VectorSpaceElement<T1> &&
	 VectorSpaceElement<T2> &&
	 std::same_as<typename pressio::Traits<T1>::scalar_type,
		      typename pressio::Traits<T2>::scalar_type>;
	 // VectorSpaceElement already implies scalar_type represents the field scalar
	};
