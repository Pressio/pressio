<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="md_pages_components_rom_galerkin" kind="page">
    <compoundname>md_pages_components_rom_galerkin</compoundname>
    <title>rom: Galerkin: high-level details</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-note m-info" /></para>
<para><parblock><para>This page explains the API for using the pressio Galerkin ROMs. After reading this, you should understand what a &quot;pressio Galerkin problem&quot; is, the variants we currently support, and how to use the problem after instantiating it.</para>
<para>If anything is unclear, and/or you have suggestions on how to improve this page, <ulink url="https://github.com/Pressio/pressio/issues">open an issue on github</ulink>. </para>
</parblock></para>
<para><linebreak/>
</para>
<sect1 id="md_pages_components_rom_galerkin_1autotoc_md90">
<title>Everything starts with creating a problem!</title>
<para>The main entry point to use the pressio Galerkin ROMs is the problem class. You create an instance of one of the supported &quot;Galerkin problems&quot; as:</para>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-block m-primary" /></para>
<para><simplesect kind="par"><title></title><para><programlisting filename=".cpp"><codeline><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">pgal<sp/><sp/><sp/><sp/>=<sp/>pressio::rom::galerkin;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>scheme<sp/>=<sp/>pressio::ode::StepScheme::some_value;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>problem<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>pgal::create_&lt;keywords&gt;(scheme,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal"><sp/>);</highlight></codeline>
</programlisting> </para>
</simplesect>
</para>
<para>where <computeroutput>&lt;keywords&gt;</computeroutput> express the variant you want (more below), <computeroutput>some_value</computeroutput> is an enum value to select the time stepping scheme (e.g., explicit Euler, RK4, BDF1, etc), and <computeroutput>args</computeroutput> are the arguments needed which depend on the variant you choose.</para>
<para>We currently offer the following variants:</para>
<para> <mcss:div xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-button m-success"> <ulink url="md_pages_components_rom_galerkin_default.html"> <mcss:div xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-medium"><ensp/><emsp/>Default Problem<emsp/> <ensp/> </mcss:div>  <mcss:div xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-small"> click to learn more </mcss:div> </ulink> </mcss:div></para>
<para> <mcss:div xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-button m-primary"> <ulink url="md_pages_components_rom_galerkin_hypred.html"> <mcss:div xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-medium">Hyper-reduced Problem </mcss:div>  <mcss:div xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-small"> click to learn more </mcss:div> </ulink> </mcss:div></para>
<para> <mcss:div xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-button m-warning"> <ulink url="md_pages_components_rom_galerkin_masked.html"> <mcss:div xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-medium"><ensp/><emsp/> Masked Problem<ensp/><emsp/> </mcss:div>  <mcss:div xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-small"> click to learn more </mcss:div> </ulink> </mcss:div></para>
</sect1>
<sect1 id="md_pages_components_rom_galerkin_1autotoc_md91">
<title>Problem class API</title>
<para>A Galerkin problem exposes different methods depending on whether you choose an explicit of implicit scheme. Below we discuss both scenarios.</para>
<sect2 id="md_pages_components_rom_galerkin_1autotoc_md92">
<title>Explicit case</title>
<para>If you create an explicit Galerkin problem, the problem exposes the following API:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">ExplicitGalerkinProblemClass</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>traits<sp/>=<sp/></highlight><highlight class="comment">/*<sp/>nested<sp/>typedef<sp/>to<sp/>access<sp/>the<sp/>problem&apos;s<sp/>traits<sp/>*/</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>ref<sp/>to<sp/>the<sp/>object<sp/>knowing<sp/>how<sp/>to<sp/>reconstruct<sp/>a<sp/>FOM<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>&amp;<sp/>fomStateReconstructor()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>TimeType,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>StepCount&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(galerkin_state_type<sp/>&amp;<sp/>state,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>TimeType<sp/>current_time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>TimeType<sp/>time_step_size_to_use,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>StepCount<sp/>step_count);</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-block m-success" /></para>
<para><simplesect kind="par"><title>Main thing to remember:</title><para>An explicit Galerkin problem satisfies the <ulink url="md_pages_components_ode_advance.html">steppable concept</ulink> (specifically, behaves like an <ulink url="md_pages_components_ode_steppers_explicit.html">explicit stepper</ulink>). </para>
</simplesect>
</para>
<para>If needed, the traits class contains:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::fom_system_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::scalar_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::decoder_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::decoder_jac_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::galerkin_state_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::galerkin_velocity_type;</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="md_pages_components_rom_galerkin_1autotoc_md93">
<title>Implicit case</title>
<para>If you create an implicit Galerkin problem, the problem exposes the following API:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">ImplicitGalerkinProblemClass</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>traits<sp/>=<sp/></highlight><highlight class="comment">/*<sp/>nested<sp/>typedef<sp/>to<sp/>access<sp/>the<sp/>problem&apos;s<sp/>traits<sp/>*/</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>scalar_type<sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::scalar_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>state_type<sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::galerkin_state_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>residual_type<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::galerkin_residual_type;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>jacobian_type<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::galerkin_jacobian_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>const<sp/>ref<sp/>to<sp/>the<sp/>object<sp/>knowing<sp/>how<sp/>to<sp/>reconstruct<sp/>a<sp/>FOM<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>&amp;<sp/>fomStateReconstructor()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>TimeType,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>StepCount,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>SolverType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>operator()(galerkin_state_type<sp/>&amp;<sp/>state,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>TimeType<sp/>current_time,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>TimeType<sp/>time_step_size_to_use,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>StepCount<sp/>step_count,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SolverType<sp/>&amp;<sp/>solver)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>NOTE:<sp/>here<sp/>we<sp/>reveal<sp/>a<sp/>bit<sp/>of<sp/>how<sp/>operator()<sp/>works.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>is<sp/>on<sp/>purpose<sp/>so<sp/>that<sp/>some<sp/>things<sp/>below<sp/>will<sp/>be<sp/>more<sp/>clear.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>The<sp/>operator()<sp/>has<sp/>3<sp/>main<sp/>stages:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>1.<sp/>we<sp/>prepare<sp/>for<sp/>doing<sp/>a<sp/>step<sp/>by<sp/>setting/updating<sp/>what<sp/>is<sp/>needed</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>2.<sp/>call<sp/>solver<sp/>(which<sp/>will<sp/>query<sp/>operators)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>solver.solve(*</highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>state);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>3.<sp/>we<sp/>do<sp/>some<sp/>other<sp/>things<sp/>to<sp/>end<sp/>the<sp/>step</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>residual_type<sp/>createResidual()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>jacobian_type<sp/>createJacobian()<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>residual(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>state_type&amp;<sp/>x,<sp/>residual_type<sp/>&amp;<sp/>res)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>jacobian(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>state_type&amp;<sp/>x,<sp/>jacobian_type<sp/>&amp;<sp/>jac)<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-block m-success" /></para>
<para><simplesect kind="par"><title>Main thing to remember:</title><para>An implicit Galerkin problem satisfies the <ulink url="md_pages_components_ode_advance.html">steppable concept</ulink> (specifically, behaves like an <ulink url="md_pages_components_ode_steppers_implicit.html">implicit stepper</ulink>). </para>
</simplesect>
</para>
<para>The traits contain:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::fom_system_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::scalar_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::decoder_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::decoder_jac_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::galerkin_state_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::galerkin_residual_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::galerkin_jacobian_type;</highlight></codeline>
</programlisting></para>
<para><linebreak/>
 <hruler/>
 <linebreak/>
</para>
</sect2>
</sect1>
<sect1 id="md_pages_components_rom_galerkin_1autotoc_md94">
<title>How do I use an EXPLICIT problem?</title>
<para>See the following:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">pode<sp/>=<sp/>pressio::ode;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">pgal<sp/>=<sp/>pressio::rom::galerkin;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>scheme<sp/>=<sp/>pdoe::StepScheme:ForwardEuler;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>problem<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>pgal::create_default_explicit_problem(scheme,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>we<sp/>assume<sp/>a<sp/>galState<sp/>exists</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>you<sp/>can<sp/>take<sp/>a<sp/>single<sp/>step<sp/>of<sp/>the<sp/>problem</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>currentTime<sp/>=<sp/>0.;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dt<sp/>=<sp/>0.5;</highlight></codeline>
<codeline><highlight class="normal">problem(galState,<sp/>currentTime,<sp/>dt,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>or<sp/>you<sp/>can<sp/>define<sp/>your<sp/>own<sp/>stepping<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>currentTime<sp/>=<sp/>0.;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dt<sp/>=<sp/>0.1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>step<sp/>=<sp/>1;<sp/>step<sp/>&lt;=<sp/>10;<sp/>step++){</highlight></codeline>
<codeline><highlight class="normal"><sp/>problem(galState,<sp/>currentTime,<sp/>dt,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/>currentTime<sp/>+=<sp/>dt;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>or<sp/>you<sp/>can<sp/>use<sp/>our<sp/>own<sp/>functions<sp/>to<sp/>advance<sp/>the<sp/>problem</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">pode::advance_n_steps(problem,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>or</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">pode::advance_n_steps_and_observe(problem,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>or<sp/>others</highlight></codeline>
</programlisting></para>
<para><linebreak/>
</para>
</sect1>
<sect1 id="md_pages_components_rom_galerkin_1autotoc_md95">
<title>How do I use an IMPLICIT problem?</title>
<para>Recall that doing implicit time stepping it is not as simple as explicit. <ulink url="md_pages_components_ode_steppers_implicit.html">For implicit, in fact, you also need a <emphasis>solver</emphasis> to compute the solution at the next step</ulink>. In the case of Galerkin, you can use a Newton-Raphson solver, because at eaach step, you are solving a (reduced) system of equations with as many equations as the number of unknowns. More specifically, the system you need to solve has as many equations as the dimensionality of your approximating subspace. See some sample snippets below:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">psolvers<sp/>=<sp/>pressio::nonlinearsolvers;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">pode<sp/><sp/><sp/><sp/><sp/>=<sp/>pressio::ode;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">pgal<sp/><sp/><sp/><sp/><sp/>=<sp/>pressio::rom::galerkin;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>scheme<sp/>=<sp/>pdoe::StepScheme:BDF1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>problem<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>pgal::create_default_implicit_problem(scheme,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>we<sp/>assume<sp/>a<sp/>galState<sp/>exists</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>for<sp/>example,<sp/>using<sp/>the<sp/>pressio<sp/>solver</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>solver<sp/>=<sp/>psolvers::create_newton_rapshon(problem,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>you<sp/>can<sp/>take<sp/>a<sp/>single<sp/>step<sp/>of<sp/>the<sp/>problem</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>currentTime<sp/>=<sp/>1.5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dt<sp/>=<sp/>0.5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>problem(galState,<sp/>currentTime,<sp/>dt,<sp/>1,<sp/>solver);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>or<sp/>you<sp/>can<sp/>define<sp/>your<sp/>own<sp/>stepping<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>currentTime<sp/>=<sp/>0.;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dt<sp/>=<sp/>0.1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>step<sp/>=<sp/>1;<sp/>step<sp/>&lt;=<sp/>10;<sp/>step++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>problem(galState,<sp/>currentTime,<sp/>dt,<sp/>1,<sp/>solver);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>currentTime<sp/>+=<sp/>dt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>or<sp/>you<sp/>can<sp/>use<sp/>our<sp/>own<sp/>functions<sp/>to<sp/>advance<sp/>the<sp/>problem</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">pode::advance_n_steps_and_observe(problem,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal">,<sp/>solver);</highlight></codeline>
</programlisting></para>
<sect2 id="md_pages_components_rom_galerkin_1autotoc_md96">
<title>Using a custom solver</title>
<para>In the snippet above, we show how to use the pressio Newton-Raphson solver to solve the Galerkin problem. If you want to use your own solver, you can do that! Here we discuss how.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>R_type,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>J_type&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">CustomSolver</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>R_type<sp/>m_R;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>J_type<sp/>m_J;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>ProblemType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CustomSolver(ProblemType<sp/>&amp;<sp/>system)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>:<sp/>m_R(system.createResidual()),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>m_J(system.createJacobian())</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>ProblemType,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>StateType&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>solve(ProblemType<sp/>&amp;<sp/>problem,<sp/>StateType<sp/>&amp;<sp/>state)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>problem<sp/>object<sp/>is<sp/>the<sp/>instance<sp/>of<sp/>the<sp/>Galerkin<sp/>problem<sp/>you<sp/>chose.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>You<sp/>can<sp/>compute<sp/>residual,<sp/>Jacobian,<sp/>etc<sp/>and<sp/>solve<sp/>as<sp/>you<sp/>wish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>for<sp/>instance,<sp/>you<sp/>can<sp/>do:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="comment">/*<sp/>some<sp/>loop<sp/>or<sp/>whatever<sp/>your<sp/>solver<sp/>needs<sp/>*/</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>problem.residual(state,<sp/>m_R);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>problem.jacobian(state,<sp/>m_J);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>with<sp/>the<sp/>residual<sp/>(m_R)<sp/>and<sp/>Jacobian<sp/>(m_J)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">pode<sp/><sp/><sp/><sp/><sp/>=<sp/>pressio::ode;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">pgal<sp/><sp/><sp/><sp/><sp/>=<sp/>pressio::rom::galerkin;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>scheme<sp/>=<sp/>pdoe::StepScheme:BDF1;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>problem<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>pgal::create_default_implicit_problem(scheme,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>traits<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>decltype(problem)::traits:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>instantiate<sp/>your<sp/>own<sp/>solver</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>and<sp/>you<sp/>can<sp/>use<sp/>it<sp/>like<sp/>shown<sp/>above</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">using<sp/>gal_R_type<sp/><sp/>=<sp/>typename<sp/>traits::galerkin_residual_type;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>gal_J_type<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>traits::galerkin_jacobian_type;</highlight></codeline>
<codeline><highlight class="normal">CustomSolver&lt;gal_R_type,<sp/>gal_J_type&gt;<sp/>yourSolver(problem);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>we<sp/>assume<sp/>a<sp/>galState<sp/>exists</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>you<sp/>can<sp/>take<sp/>a<sp/>single<sp/>step<sp/>of<sp/>the<sp/>problem</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>currentTime<sp/>=<sp/>0.;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dt<sp/>=<sp/>0.5;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>problem(galState,<sp/>currentTime,<sp/>dt,<sp/>1,<sp/>yourSolver);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>or<sp/>you<sp/>can<sp/>define<sp/>your<sp/>own<sp/>stepping<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>currentTime<sp/>=<sp/>0.;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>dt<sp/>=<sp/>0.1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>step<sp/>=<sp/>1;<sp/>step<sp/>&lt;=<sp/>10;<sp/>step++){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>problem(galState,<sp/>currentTime,<sp/>dt,<sp/>1,<sp/>yourSolver);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>currentTime<sp/>+=<sp/>dt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>or<sp/>you<sp/>can<sp/>use<sp/>our<sp/>own<sp/>functions<sp/>to<sp/>advance<sp/>the<sp/>problem</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">pode::advance_n_steps_and_observe(problem,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal">,<sp/>yourSolver);</highlight></codeline>
</programlisting></para>
<para> <mcss:class xmlns:mcss="http://mcss.mosra.cz/doxygen/" mcss:class="m-block m-warning" /></para>
<para><simplesect kind="par"><title>Pay attention to:</title><para>If you need fine-grained access, i.e., you need to make the problem take a single step (in other words you don&apos;t use our own <computeroutput>advance</computeroutput> methods), you should <emphasis>always</emphasis> just rely on <computeroutput>operator()</computeroutput>. To be more explicit, look at this snippet: <programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>assume<sp/>we<sp/>have<sp/>a<sp/>galState</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>problem<sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>pgal::create_default_implicit_problem(scheme,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">solver<sp/>=<sp/></highlight><highlight class="comment">//<sp/>create<sp/>solver<sp/>somehow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>!!!<sp/>You<sp/>should<sp/>NOT<sp/>do<sp/>this,<sp/>this<sp/>is<sp/>undefined<sp/>behavior<sp/>!!!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">solver.solve(problem,<sp/>galState)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>You<sp/>should<sp/>do<sp/>this:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">problem(...,<sp/>solver);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>or,<sp/>better,<sp/>rely<sp/>on<sp/>(the<sp/>advance<sp/>functions<sp/>do<sp/>the<sp/>right<sp/>thing<sp/>behind<sp/>the<sp/>scenes)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">pode::advance_n_steps_and_observe(problem,<sp/></highlight><highlight class="comment">/*<sp/>args<sp/>*/</highlight><highlight class="normal">,<sp/>solver);</highlight></codeline>
</programlisting> </para>
</simplesect>
</para>
<para><linebreak/>
 <hruler/>
 <linebreak/>
</para>
</sect2>
</sect1>
<sect1 id="md_pages_components_rom_galerkin_1autotoc_md97">
<title>Why does a Galerkin problem behave like a stepper?</title>
<para>The answer is that practically speaking, at the lowest-level, a Galerkin problem can be reduced to simply a &quot;custom&quot; stepper to advance in time. This is how pressio implements this and the reason why a Galerkin problem contains a stepper object inside: when you create the problem, pressio creates the appropriate custom stepper object that you can use. You don&apos;t need to know how this is done, or rely on the details, because these are problem- and implementation-dependent, and we reserve the right to change this in the future. All you need to know is that a an explicit Galerkin problem behaves like a an explicit stepper, and an implicit Galerkin problem behaves like an implicit stepper. </para>
</sect1>
    </detaileddescription>
    <location file="pages/components/rom_galerkin.md"/>
  </compounddef>
</doxygen>
