

Defined in\+: {\ttfamily $<$pressio/rom\+\_\+lspg.\+hpp$>$}

Public namespace\+: {\ttfamily pressio\+::rom\+::lspg} 

~\newline




\begin{DoxyParagraph}{Prerequisite reading\+:}
Before you read this page, make sure you read the \href{md_pages_components_rom_lspg_unsteady.html}{\texttt{ overall design idea of the unsteady LSPG}}. 
\end{DoxyParagraph}
\hypertarget{md_pages_components_rom_lspg_hypred_autotoc_md120}{}\doxysection{API}\label{md_pages_components_rom_lspg_hypred_autotoc_md120}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// overload for continuous-\/time systems}}
\DoxyCodeLine{\textcolor{keyword}{template}<}
\DoxyCodeLine{  \textcolor{keyword}{class }FomSystemType,}
\DoxyCodeLine{  \textcolor{keyword}{class }DecoderType,}
\DoxyCodeLine{  \textcolor{keyword}{class }RomStateType,                                                             (1)}
\DoxyCodeLine{  \textcolor{keyword}{class} FomReferenceStateType,}
\DoxyCodeLine{  \textcolor{keyword}{class} HypRedOperatorUpdaterType}
\DoxyCodeLine{  >}
\DoxyCodeLine{ReturnType create\_hyperreduced\_unsteady\_problem(pressio::ode::StepScheme scheme,}
\DoxyCodeLine{                                                \textcolor{keyword}{const} FomSystemType \& fomSystem,}
\DoxyCodeLine{                                                DecoderType \& decoder,}
\DoxyCodeLine{                                                \textcolor{keyword}{const} RomStateType \& romState,}
\DoxyCodeLine{                                                \textcolor{keyword}{const} FomReferenceStateType \& fomRefState,}
\DoxyCodeLine{                                                \textcolor{keyword}{const} HypRedOperatorUpdaterType \& hrUpdater)}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// overload for discrete-\/time systems}}
\DoxyCodeLine{\textcolor{keyword}{template}<}
\DoxyCodeLine{  std::size\_t num\_states,}
\DoxyCodeLine{  \textcolor{keyword}{class }FomSystemType,}
\DoxyCodeLine{  \textcolor{keyword}{class }DecoderType,}
\DoxyCodeLine{  \textcolor{keyword}{class }RomStateType,                                                             (2)}
\DoxyCodeLine{  \textcolor{keyword}{class} FomReferenceStateType}
\DoxyCodeLine{  >}
\DoxyCodeLine{ReturnType create\_hyperreduced\_unsteady\_problem(\textcolor{keyword}{const} FomSystemType \& fomSystem,}
\DoxyCodeLine{                                                DecoderType \& decoder,}
\DoxyCodeLine{                                                \textcolor{keyword}{const} RomStateType \& romState,}
\DoxyCodeLine{                                                \textcolor{keyword}{const} FomReferenceStateType \& fomRefState);}

\end{DoxyCode}
\hypertarget{md_pages_components_rom_lspg_hypred_autotoc_md121}{}\doxysubsection{Parameters and Requirements}\label{md_pages_components_rom_lspg_hypred_autotoc_md121}

\begin{DoxyItemize}
\item {\ttfamily fom\+System}\+:
\begin{DoxyItemize}
\item instance of your adapter class type specifying the FOM problem
\item for 1\+: must satisfy the \href{./md_pages_components_rom_fom_apis.html}{\texttt{ continuous-\/time API}}
\item for 2\+: must satisfy the \href{./md_pages_components_rom_fom_apis.html}{\texttt{ discrete-\/time API}}
\end{DoxyItemize}
\item {\ttfamily decoder}\+:
\begin{DoxyItemize}
\item decoder object
\item must satify the requirements listed \href{md_pages_components_rom_decoder.html}{\texttt{ here}}
\end{DoxyItemize}
\item {\ttfamily rom\+State}\+:
\begin{DoxyItemize}
\item currently, it must be either an Eigen vector or a Kokkos 1D view
\end{DoxyItemize}
\item {\ttfamily fom\+Ref\+State}\+:
\begin{DoxyItemize}
\item your FOM reference state that is used when reconstructing the FOM state
\item must be copy-\/constructible and the following must be true\+:~\newline
 
\begin{DoxyCode}{0}
\DoxyCodeLine{std::is\_same<FomReferenceStateType, typename DecoderType::fom\_state\_type>::value == \textcolor{keyword}{true}}

\end{DoxyCode}

\end{DoxyItemize}
\item {\ttfamily hr\+Updater}\+:
\begin{DoxyItemize}
\item an instance of class that knows how to update operands that live on the stencil and sample mesh.
\item must meet the following interface\+:
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct }HypRedUpdater}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{using} operand\_type1 = \textcolor{comment}{/*should be the type of your fom velocity*/};}
\DoxyCodeLine{  \textcolor{keyword}{using} operand\_type2 = \textcolor{comment}{/*should be the type of your decoder's jacobian*/};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{class} ScalarType>}
\DoxyCodeLine{  \textcolor{keywordtype}{void} updateSampleMeshOperandWithStencilMeshOne(operand\_type1 \& operand\_on\_sample,}
\DoxyCodeLine{                                                 ScalarType alpha,}
\DoxyCodeLine{                                                 \textcolor{keyword}{const} operand\_type1 \& operand\_on\_stencil,}
\DoxyCodeLine{                                                 ScalarType beta)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{}
\DoxyCodeLine{    \textcolor{comment}{// appropriately compute:}}
\DoxyCodeLine{    \textcolor{comment}{// operand\_on\_sample = alpha*operand\_on\_sample + beta*operand\_on\_stencil}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{class} ScalarType>}
\DoxyCodeLine{  \textcolor{keywordtype}{void} updateSampleMeshOperandWithStencilMeshOne(operand\_type2 \& operand\_on\_sample,}
\DoxyCodeLine{                                                 ScalarType alpha,}
\DoxyCodeLine{                                                 \textcolor{keyword}{const} operand\_type2 \& operand\_on\_stencil,}
\DoxyCodeLine{                                                 ScalarType beta)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{}
\DoxyCodeLine{    \textcolor{comment}{// appropriately compute:}}
\DoxyCodeLine{    \textcolor{comment}{// operand\_on\_sample = alpha*operand\_on\_sample + beta*operand\_on\_stencil}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}

\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily num\+\_\+states}\+:
\begin{DoxyItemize}
\item {\itshape total} number of states you need to use (must be $<$= 3), if you need more open issue
\item only needed for the discrete-\/time case
\end{DoxyItemize}
\end{DoxyItemize}

~\newline
\hypertarget{md_pages_components_rom_lspg_hypred_autotoc_md122}{}\doxysection{Why do we need the Hyp\+Red\+Updater?}\label{md_pages_components_rom_lspg_hypred_autotoc_md122}
When working with a hyper-\/reduced problem, pressio has to manipulate objects that have different sizes/distributions. For this problem variant, in fact, some operators are naturally defined on the what we refer to as \char`\"{}sample mesh\char`\"{} while some are defined on what we call the \char`\"{}stencil mesh\char`\"{}.

As explained \href{https://pressio.github.io/algos/hyper/}{\texttt{ here}}, recall that\+:


\begin{DoxyEnumerate}
\item {\bfseries{sample mesh}}\+: a disjoint collection of elements where the velocity (or residual) operator is computed.
\item {\bfseries{stencil mesh}}\+: the set of all nodes or elements needed to compute the velocity or residual on the sample mesh.
\item Typically, the sample mesh is a subset of the stencil mesh.
\end{DoxyEnumerate}



The {\ttfamily hr\+Updater} is an object that knows how to compute {\ttfamily a$\ast$x + b$\ast$y} for operands {\ttfamily x,y,} that (potentially) do NOT have the same size/data distribution since they are defined on stencil and sample mesh. \hypertarget{md_pages_components_rom_lspg_hypred_autotoc_md123}{}\doxysubsection{Explain it to me better!}\label{md_pages_components_rom_lspg_hypred_autotoc_md123}
Suppose that your FOM problem involves a 2D problem and that your FOM numerical method needs at every cell information from the nearest neighbors. For the sake of explanation, {\itshape it does not matter what problem we are solving}, only what we just said. Now, suppose that you want to try hyper-\/reduced LSPG on it. You come up with a sample and stencil mesh for your problem (read \href{https://pressio.github.io/algos/hyper/}{\texttt{ this page}} for some information about how to select sample mesh cells), and let\textquotesingle{}s say it looks like this\+: 

The stencil mesh is the set of {\itshape all} cells shown, while the sample mesh is the {\itshape subset} color-\/coded yellow. We have added an arbitrary enumeration scheme to uniquely assign a global index to each cell. The enumeration order does not matter, this is just for demonstration purposes. You have an adapter class for your problem that is able to compute the FOM right-\/hand-\/side $f$ on the yellow cells, for a given FOM state $y$ on the stencil mesh.

For this example, you would need to create an {\ttfamily Hyp\+Red\+Updater} object capable of performing those operations on operands that defined on the visualized sample and stencil meshes.

todo\+: explain that this is application-\/specific. There is nothing we can be to make this simple for generic applications, but we can simplify this for shared-\/mem ones and users can fully omit this for Trilinos based applications since we can use the underlying maps to figure out how to combine operators. 