

\begin{DoxyParagraph}{}
This tutorial shows how to create a pressio linear decoder object.
\end{DoxyParagraph}
\hypertarget{md_pages_tutorials_tutorial1_autotoc_md39}{}\doxysection{Context}\label{md_pages_tutorials_tutorial1_autotoc_md39}
A key assumption of projection-\/based R\+O\+Ms is to approximate the full-\/order model (F\+OM) state, $y_{fom}$, as\+: \[ y_{fom} = g(y_{rom}) \]

where $y_{rom}$ is the reduced state (or generalized coordinates), and $g$ is the mapping between the two.

If $g$ is linear, then we can write\+: \[ y_{fom} = \phi y_{rom} \] where $\phi$ is a matrix (for the time being, assume it constant). The Jacobian of the mapping is\+: \[ \frac{d y_{fom}}{d y_{rom}} = \phi. \]

Graphically, this corresponds to\+: 

{\itshape A linear decoder in pressio implements this linear mapping.}\hypertarget{md_pages_tutorials_tutorial1_autotoc_md40}{}\doxysection{Types Description}\label{md_pages_tutorials_tutorial1_autotoc_md40}

\begin{DoxyItemize}
\item $y_{fom}$\+: this is the F\+OM state and, therefore, it is a data structure of your application. For example, if you are using Trilinos/\+Epetra, the F\+OM state can be, e.\+g., an Epetra vector. Typically, $y_{fom}$ is a large (distributed) vector.
\item $\phi$\+: this is the matrix of the linear mapping (e.\+g. P\+OD modes). Should be a data structure from your application. For example, if you are using Trilinos/\+Epetra, the F\+OM state can be, e.\+g., an Epetra Multi\+Vector. Typically, $\phi$ is a large (distributed) matrix.
\item $y_{rom}$\+: this is the R\+OM state. R\+OM data strutures generally involve small, dense operators that fit well on a single node. In pressio, {\itshape regardless of what the F\+OM types are}, the R\+OM operators/data structures are either Eigen (always enabled) or Kokkos (optional dependency) types.
\end{DoxyItemize}\hypertarget{md_pages_tutorials_tutorial1_autotoc_md41}{}\doxysection{Scenario A\+: your F\+O\+M types are natively supported in pressio}\label{md_pages_tutorials_tutorial1_autotoc_md41}
This case refers to data types which pressio knows how to manipulate and operate on. Examples include vector and matrix classes in Eigen, Epetra/\+Tpetra in Trilinos, or Kokkos views. What do we mean by {\itshape natively supported}? If you try to use a pressio functionality/class using data structure types that are already supported/known to pressio, pressio {\itshape detects} them, and automatically uses the (best) native kernels to perform computations. The full list of supported data structures types can be found \mbox{[}here\mbox{]}(todo).

Here, for demonstration purposes, we pretend the F\+OM uses Eigen types too. For other F\+OM types already known to pressio it would work similarly. The full tutorial can be found \href{https://github.com/Pressio/pressio-tutorials/blob/master/tutorials/tutorial4.cc}{\texttt{ here}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"{}Running tutorial 4\(\backslash\)n"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{   creating a linear decoder (or mapping) object representing}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{     yFom = phi * yRom}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{   where yFom is the FOM state, yRom is the reduced state,}}
\DoxyCodeLine{\textcolor{comment}{   and phi is a matrix (for the time being, assume it constant).}}
\DoxyCodeLine{\textcolor{comment}{  */}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** define types ***}}
\DoxyCodeLine{  \textcolor{keyword}{using} native\_fom\_state\_t = Eigen::VectorXd;}
\DoxyCodeLine{  \textcolor{keyword}{using} native\_phi\_t       = Eigen::MatrixXd;}
\DoxyCodeLine{  \textcolor{comment}{// wrap types using pressio containers}}
\DoxyCodeLine{  \textcolor{keyword}{using} fom\_state\_t   = pressio::containers::Vector<native\_fom\_state\_t>;}
\DoxyCodeLine{  \textcolor{keyword}{using} decoder\_jac\_t = pressio::containers::DenseMatrix<native\_phi\_t>;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** create native phi ***}}
\DoxyCodeLine{  \textcolor{comment}{// for simplicity, phi is filled with ones}}
\DoxyCodeLine{  native\_phi\_t phiNative(6, 3);}
\DoxyCodeLine{  phiNative.setConstant(1.);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** construct decoder  ***}}
\DoxyCodeLine{  \textcolor{keyword}{using} decoder\_t = pressio::rom::LinearDecoder<decoder\_jac\_t, fom\_state\_t>;}
\DoxyCodeLine{  \textcolor{comment}{// by moving phiNative (since Eigen supports move semantics) we avoid a deep copy.}}
\DoxyCodeLine{  \textcolor{comment}{// Note that after the move, you should not use phiNative directly.}}
\DoxyCodeLine{  \textcolor{comment}{// One also do `decoderObj(phi)` which implies a copy of the matrix.}}
\DoxyCodeLine{  \textcolor{comment}{// Obviously, if the matrix is large avoiding a copy is useful.}}
\DoxyCodeLine{  decoder\_t decoder(std::move(phiNative));}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** construct reduced state  ***}}
\DoxyCodeLine{  \textcolor{comment}{// pressio ROM state is always either Eigen or Kokkos (if enabled)}}
\DoxyCodeLine{  \textcolor{keyword}{using} rom\_state\_t = pressio::containers::Vector<Eigen::VectorXd>;}
\DoxyCodeLine{  rom\_state\_t yRom(3);}
\DoxyCodeLine{  \textcolor{comment}{// fill with 2.}}
\DoxyCodeLine{  pressio::ops::fill(yRom, 2.);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** apply mapping ***}}
\DoxyCodeLine{  fom\_state\_t yFom(6);}
\DoxyCodeLine{  decoder.applyMapping(yRom, yFom);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** check solution ***}}
\DoxyCodeLine{  \textcolor{comment}{// yFom should be = [4. 4. ..., 4.]}}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i=0; i<yFom.extent(0); ++i)}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}i= "{}} << i}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}, yFom(i) = "{}}  << yFom(i)}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}, expected = "{}} << 4.}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{md_pages_tutorials_tutorial1_autotoc_md42}{}\doxysection{Scenario B\+: your F\+O\+M types are N\+O\+T natively supported in pressio}\label{md_pages_tutorials_tutorial1_autotoc_md42}
This case refers to data types which pressio does {\itshape not} know how to manipulate and operate on. What do we mean by {\itshape not natively supported}? If you try to use a pressio functionality/class usign a data structure type that is {\bfseries{N\+OT}} already supported/known to pressio, pressio {\itshape detects/labels} it as an {\itshape arbitrary} type, and you {\bfseries{have to}} provide pressio with kernels to operate on these types.

Here, for demonstration, we pretend that\+:
\begin{DoxyItemize}
\item $y_{fom}$ is a {\ttfamily std\+::vector$<$$>$}
\item $\phi$ is a {\ttfamily std\+::vector$<$std\+::vector$<$$>$$>$}
\end{DoxyItemize}

Note that the code below would work for any other "{}arbitrary\textquotesingle{}\textquotesingle{} (not known to pressio) type, whether they are distributed or not. The full tutorial can be found \href{https://github.com/Pressio/pressio-tutorials/blob/master/tutorials/tutorial5.cc}{\texttt{ here}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char} *argv[])}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"{}Running tutorial 5\(\backslash\)n"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{/*}}
\DoxyCodeLine{\textcolor{comment}{   creating a linear decoder (or mapping) object representing}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{     yFom = phi * yRom}}
\DoxyCodeLine{\textcolor{comment}{}}
\DoxyCodeLine{\textcolor{comment}{   where yFom is the FOM state, yRom is the reduced state,}}
\DoxyCodeLine{\textcolor{comment}{   and phi is a matrix (for the time being, assume it constant).}}
\DoxyCodeLine{\textcolor{comment}{  */}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** define types ***}}
\DoxyCodeLine{  \textcolor{comment}{// the FOM application uses std::vector}}
\DoxyCodeLine{  \textcolor{keyword}{using} scalar\_t       = double;}
\DoxyCodeLine{  \textcolor{keyword}{using} native\_fom\_state\_t = std::vector<scalar\_t>;}
\DoxyCodeLine{  \textcolor{keyword}{using} native\_phi\_t       = std::vector<std::vector<scalar\_t>>;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// the wrapped types}}
\DoxyCodeLine{  \textcolor{comment}{// what happens in pressio when we wrap native\_fom\_state\_t and native\_phi\_t?}}
\DoxyCodeLine{  \textcolor{comment}{// Practically, both pressio::containers::Vector<native\_fom\_state\_t>}}
\DoxyCodeLine{  \textcolor{comment}{// and pressio::containers::DenseMatrix<native\_fom\_state\_t> are "{}labeled"{}}}
\DoxyCodeLine{  \textcolor{comment}{// as "{}arbitrary"{} wrapper types for which pressio does not know how to operate on.}}
\DoxyCodeLine{  \textcolor{keyword}{using} fom\_state\_t   = pressio::containers::Vector<native\_fom\_state\_t>;}
\DoxyCodeLine{  \textcolor{keyword}{using} decoder\_jac\_t = pressio::containers::DenseMatrix<native\_phi\_t>;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** fill phi ***}}
\DoxyCodeLine{  \textcolor{comment}{// create a native phi and fill with ones}}
\DoxyCodeLine{  native\_phi\_t phiNative(6);}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \& iRow : phiNative)\{}
\DoxyCodeLine{    iRow.resize(3, 1.);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** construct decoder  ***}}
\DoxyCodeLine{  \textcolor{comment}{// Since the FOM types are "{}arbitrary"{}, we need to declare the}}
\DoxyCodeLine{  \textcolor{comment}{// decoder type by passing as a template argument the type of}}
\DoxyCodeLine{  \textcolor{comment}{// class (see MyOps struct in this file) containing kernels for operating on the data.}}
\DoxyCodeLine{  \textcolor{comment}{// And we need to pass an object to the constructor of the decoder}}
\DoxyCodeLine{  \textcolor{comment}{// an object that knows how to compute the the operations needed.}}
\DoxyCodeLine{  \textcolor{keyword}{using} ops\_t     = MyOps<scalar\_t>;}
\DoxyCodeLine{  \textcolor{keyword}{using} decoder\_t = pressio::rom::LinearDecoder<decoder\_jac\_t, fom\_state\_t, ops\_t>;}
\DoxyCodeLine{  ops\_t ops;}
\DoxyCodeLine{  decoder\_t decoder(phiNative, ops);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** construct reduced state  ***}}
\DoxyCodeLine{  \textcolor{comment}{// use Eigen for the ROM state}}
\DoxyCodeLine{  \textcolor{keyword}{using} rom\_state\_t = pressio::containers::Vector<Eigen::VectorXd>;}
\DoxyCodeLine{  rom\_state\_t yRom(3);}
\DoxyCodeLine{  \textcolor{comment}{// fill with 2.}}
\DoxyCodeLine{  pressio::ops::fill(yRom, 2.);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** apply mapping ***}}
\DoxyCodeLine{  fom\_state\_t yFom(6);}
\DoxyCodeLine{  decoder.applyMapping(yRom, yFom);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// *** check solution ***}}
\DoxyCodeLine{  \textcolor{comment}{// yFom should be = [4. 4. .... 4.]}}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i=0; i<6; ++i)}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"{}i= "{}} << i}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}, yFom(i) = "{}}  << yFom(i)}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}, expected = "{}} << 4.}
\DoxyCodeLine{          << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\end{DoxyCode}
\hypertarget{md_pages_tutorials_tutorial1_autotoc_md43}{}\doxysubsection{The ops struct}\label{md_pages_tutorials_tutorial1_autotoc_md43}
In order for pressio to handle the linear mapping, it needs to know how to operate on $\phi$. To this end, in the code above, you need to pass to the {\ttfamily Linear\+Decoder} constructor an object to handle that computation. To compute the mapping, pressio will call the {\ttfamily product} method. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} scalar\_t>}
\DoxyCodeLine{\textcolor{keyword}{struct }MyOps}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// z = beta*z + alpha * A * x}}
\DoxyCodeLine{  \textcolor{comment}{// where x is something that is subscritable as x(i)}}
\DoxyCodeLine{  \textcolor{keyword}{template}< \textcolor{keyword}{typename} x\_t>}
\DoxyCodeLine{  \textcolor{keywordtype}{void} product(pressio::nontranspose,}
\DoxyCodeLine{           scalar\_t alpha,}
\DoxyCodeLine{           \textcolor{keyword}{const} std::vector<std::vector<scalar\_t>> \& A,}
\DoxyCodeLine{           \textcolor{keyword}{const} x\_t \& x,}
\DoxyCodeLine{           scalar\_t beta,}
\DoxyCodeLine{           std::vector<scalar\_t> \& z)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{}
\DoxyCodeLine{    \textcolor{comment}{// obviously not efficient, just for demonstration}}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (std::size\_t i=0; i<A.size(); ++i)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      z[i] += beta*z[i];}
\DoxyCodeLine{      \textcolor{keywordflow}{for} (std::size\_t j=0; j<A[i].size(); ++j)\{}
\DoxyCodeLine{       z[i] += alpha*A[i][j]*x(j);}
\DoxyCodeLine{      \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
\hypertarget{md_pages_tutorials_tutorial1_autotoc_md44}{}\doxysection{Comments}\label{md_pages_tutorials_tutorial1_autotoc_md44}
We are constantly working increasing support in pressio for more external libraries. If you application types are not supported but you would like them to be, you can file an \href{https://github.com/Pressio/pressio/issues}{\texttt{ issue}} to request it. 